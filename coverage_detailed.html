
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>scheduler: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">chronos-kubernetes-scheduler/cmd/scheduler/main.go (0.0%)</option>
				
				<option value="file1">chronos-kubernetes-scheduler/internal/scheduler/plugin.go (70.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "os"

        "chronos-kubernetes-scheduler/internal/scheduler"

        "k8s.io/klog/v2"
        "k8s.io/kubernetes/cmd/kube-scheduler/app"
)

// main is the entry point for the scheduler.
func main() <span class="cov0" title="0">{
        command := app.NewSchedulerCommand(
                app.WithPlugin(scheduler.PluginName, scheduler.New),
        )

        if err := command.Execute(); err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("Error executing scheduler command: %v", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scheduler

import (
        "context"
        "fmt"
        "math"
        "strconv"
        "time"

        v1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/klog/v2"
        "k8s.io/kubernetes/pkg/scheduler/framework"
)

const (
        // PluginName is the name of the custom scheduler plugin.
        PluginName = "Chronos"
        // JobDurationAnnotation is the annotation on a pod that specifies its expected runtime in seconds.
        JobDurationAnnotation = "scheduling.workload.io/expected-duration-seconds"
        // maxPossibleScore - A large constant to invert the score. A lower completion time will result in a higher raw score.
        // Set to ~3.17 years (100,000,000 seconds ≈ 1,157 days) to provide excellent granularity for virtually all workloads.
        maxPossibleScore = 100000000

        // Utilization bonus - higher value gives stronger preference to less utilized nodes
        utilizationBonus = 10000 // Points per available slot
)

// Chronos is a scheduler plugin that uses bin-packing logic with extension minimization
// to optimize resource utilization and minimize cluster commitment extensions.
type Chronos struct {
        handle framework.Handle
}

// New initializes a new plugin and returns it.
func New(_ runtime.Object, h framework.Handle) (framework.Plugin, error) <span class="cov2" title="2">{
        klog.Infof("Initializing Chronos plugin with bin-packing + extension minimization + utilization optimization")
        return &amp;Chronos{
                handle: h,
        }, nil
}</span>

// Name returns the name of the plugin.
func (s *Chronos) Name() string <span class="cov2" title="3">{
        return PluginName
}</span>

// Score is the core scheduling logic. It calculates a score for each node based on
// when the node is expected to become idle.
func (s *Chronos) Score(ctx context.Context, state *framework.CycleState, p *v1.Pod, nodeName string) (int64, *framework.Status) <span class="cov2" title="3">{
        klog.Infof("Scoring pod %s/%s for node %s", p.Namespace, p.Name, nodeName)

        // 1. Get the expected duration of the pod being scheduled.
        newPodDurationStr, ok := p.Annotations[JobDurationAnnotation]
        if !ok </span><span class="cov1" title="1">{
                klog.Infof("Pod %s/%s is missing annotation %s, skipping.", p.Namespace, p.Name, JobDurationAnnotation)
                return 0, framework.NewStatus(framework.Success)
        }</span>
        <span class="cov2" title="2">newPodDuration, err := strconv.ParseInt(newPodDurationStr, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                klog.Warningf("Could not parse duration '%s' for pod %s/%s: %v", newPodDurationStr, p.Namespace, p.Name, err)
                return 0, framework.NewStatus(framework.Success)
        }</span>

        // 2. Get node information.
        <span class="cov1" title="1">nodeInfo, err := s.handle.SnapshotSharedLister().NodeInfos().Get(nodeName)
        if err != nil </span><span class="cov0" title="0">{
                klog.Errorf("Error getting node info for %s: %v", nodeName, err)
                return 0, framework.NewStatus(framework.Error, fmt.Sprintf("getting node %q info: %s", nodeName, err))
        }</span>

        // 3. Calculate the maximum remaining time for all pods currently on the node.
        <span class="cov0" title="0">maxRemainingTime := int64(0)
        now := time.Now()

        for _, existingPodInfo := range nodeInfo.Pods </span><span class="cov0" title="0">{
                existingPod := existingPodInfo.Pod
                if existingPod.Status.Phase == v1.PodSucceeded || existingPod.Status.Phase == v1.PodFailed </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">durationStr, ok := existingPod.Annotations[JobDurationAnnotation]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">duration, err := strconv.ParseInt(durationStr, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if existingPod.Status.StartTime == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">startTime := existingPod.Status.StartTime.Time
                elapsedSeconds := now.Sub(startTime).Seconds()
                remainingSeconds := duration - int64(elapsedSeconds)
                if remainingSeconds &lt; 0 </span><span class="cov0" title="0">{
                        remainingSeconds = 0
                }</span>
                <span class="cov0" title="0">if remainingSeconds &gt; maxRemainingTime </span><span class="cov0" title="0">{
                        maxRemainingTime = remainingSeconds
                }</span>
        }

        // 4. Calculate completion time using bin-packing logic
        <span class="cov0" title="0">nodeCompletionTime := s.calculateBinPackingCompletionTime(maxRemainingTime, newPodDuration)

        // 5. Apply two-phase optimization strategy
        score := s.calculateOptimizedScore(nodeInfo, maxRemainingTime, newPodDuration, nodeCompletionTime)

        klog.Infof("Pod: %s/%s, Node: %s, Existing: %ds, NewJob: %ds, Completion: %ds, Score: %d (optimized)",
                p.Namespace, p.Name, nodeName, maxRemainingTime, newPodDuration, nodeCompletionTime, score)

        return score, framework.NewStatus(framework.Success)</span>
}

// calculateBinPackingCompletionTime implements true bin-packing logic:
// If new job fits within existing work window, completion time doesn't change
func (s *Chronos) calculateBinPackingCompletionTime(maxRemainingTime, newPodDuration int64) int64 <span class="cov9" title="236">{
        if newPodDuration &lt;= maxRemainingTime </span><span class="cov8" title="93">{
                // Job fits within existing work window - completion time stays the same
                // This is the key insight: jobs can run concurrently within the window!
                return maxRemainingTime
        }</span>

        // Job extends beyond existing work - completion time becomes the new job duration
        <span class="cov9" title="143">return newPodDuration</span>
}

// calculateOptimizedScore implements the two-phase optimization strategy:
// Phase 1: If job extends beyond existing work → Choose best utilization (excluding empty nodes)
// Phase 2: If job fits within existing work → Choose node with longest existing work (consolidation)
func (s *Chronos) calculateOptimizedScore(nodeInfo *framework.NodeInfo, maxRemainingTime int64, newPodDuration int64, nodeCompletionTime int64) int64 <span class="cov9" title="232">{
        // Get current pod count
        currentPods := len(nodeInfo.Pods)

        // Calculate utilization metrics
        estimatedCapacity := s.estimateNodeCapacity(nodeInfo)
        availableSlots := estimatedCapacity - currentPods
        if availableSlots &lt; 0 </span><span class="cov1" title="1">{
                availableSlots = 0
        }</span>

        <span class="cov9" title="232">var finalScore int64
        var strategy string

        if maxRemainingTime &gt; 0 &amp;&amp; newPodDuration &gt; maxRemainingTime </span><span class="cov8" title="128">{
                // CASE 1: Job extends beyond existing work
                // Choose based on utilization bonus, excluding empty nodes

                utilizationScore := int64(availableSlots) * utilizationBonus
                finalScore = utilizationScore
                strategy = "extension-utilization"

                klog.V(4).Infof("Node %s: EXTENSION case - NewJob=%ds &gt; Existing=%ds, UtilScore=%d",
                        nodeInfo.Node().Name, newPodDuration, maxRemainingTime, utilizationScore)

        }</span> else<span class="cov8" title="104"> if maxRemainingTime &gt; 0 </span><span class="cov8" title="88">{
                // CASE 2: Job fits within existing work
                // Choose node with longest existing work (consolidation) + utilization tie-breaker

                consolidationScore := maxRemainingTime
                utilizationScore := int64(availableSlots) * (utilizationBonus / 10) // Lower weight for tie-breaking
                finalScore = consolidationScore + utilizationScore
                strategy = "consolidation"

                klog.V(4).Infof("Node %s: CONSOLIDATION case - NewJob=%ds fits in Existing=%ds, ConsolScore=%d, UtilScore=%d",
                        nodeInfo.Node().Name, newPodDuration, maxRemainingTime, consolidationScore, utilizationScore)

        }</span> else<span class="cov5" title="16"> {
                // CASE 3: Empty node - heavily penalized
                finalScore = int64(availableSlots) * (utilizationBonus / 100) // Very low score
                strategy = "empty-penalty"

                klog.V(4).Infof("Node %s: EMPTY node penalty, Score=%d",
                        nodeInfo.Node().Name, finalScore)
        }</span>

        <span class="cov9" title="232">klog.V(4).Infof("Node %s: Strategy=%s, Pods=%d/%d, Available=%d, Final=%d",
                nodeInfo.Node().Name, strategy, currentPods, estimatedCapacity, availableSlots, finalScore)

        return finalScore</span>
}

// estimateNodeCapacity provides a rough estimate of how many pods a node can handle
// This could be made more sophisticated based on actual resource calculations
func (s *Chronos) estimateNodeCapacity(nodeInfo *framework.NodeInfo) int <span class="cov10" title="245">{
        node := nodeInfo.Node()

        // Simple heuristic based on node resources
        // In production, this could consider actual CPU/memory requirements
        allocatableCPU := node.Status.Allocatable.Cpu().MilliValue()

        // Assume average pod needs 100m CPU
        estimatedCapacity := int(allocatableCPU / 100)

        // Cap at reasonable limits
        if estimatedCapacity &lt; 5 </span><span class="cov2" title="2">{
                estimatedCapacity = 5
        }</span>
        <span class="cov10" title="245">if estimatedCapacity &gt; 50 </span><span class="cov9" title="200">{
                estimatedCapacity = 50
        }</span>

        <span class="cov10" title="245">return estimatedCapacity</span>
}

// ScoreExtensions of the Score plugin.
func (s *Chronos) ScoreExtensions() framework.ScoreExtensions <span class="cov2" title="2">{
        return s
}</span>

// NormalizeScore is the key to making this work for jobs of any duration.
// It takes the raw scores from the Score function and scales them to a 0-100 range.
func (s *Chronos) NormalizeScore(ctx context.Context, state *framework.CycleState, pod *v1.Pod, scores framework.NodeScoreList) *framework.Status <span class="cov3" title="4">{
        var minScore, maxScore int64 = math.MaxInt64, math.MinInt64

        for _, nodeScore := range scores </span><span class="cov4" title="11">{
                if nodeScore.Score &lt; minScore </span><span class="cov3" title="4">{
                        minScore = nodeScore.Score
                }</span>
                <span class="cov4" title="11">if nodeScore.Score &gt; maxScore </span><span class="cov4" title="9">{
                        maxScore = nodeScore.Score
                }</span>
        }

        // If all scores are the same, set them all to maximum score.
        <span class="cov3" title="4">if maxScore == minScore </span><span class="cov1" title="1">{
                for i := range scores </span><span class="cov2" title="3">{
                        scores[i].Score = framework.MaxNodeScore // Give all nodes a perfect score
                }</span>
                <span class="cov1" title="1">return nil</span>
        }

        <span class="cov2" title="3">for i, nodeScore := range scores </span><span class="cov4" title="8">{
                // Formula to scale a value from one range [min, max] to another [0, 100].
                normalized := (nodeScore.Score - minScore) * framework.MaxNodeScore / (maxScore - minScore)
                scores[i].Score = normalized
                klog.Infof("Pod: %s/%s, Node: %s, RawScore: %d, NormalizedScore: %d", pod.Namespace, pod.Name, nodeScore.Name, nodeScore.Score, normalized)
        }</span>

        <span class="cov2" title="3">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
