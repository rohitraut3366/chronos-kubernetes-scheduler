name: Release

on:
  push:
    tags:
      - 'v*.*.*'  # Trigger on semantic version tags like v1.0.0
  # Allow manual triggering
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to release (e.g., v1.0.0)'
        required: true
        type: string

env:
  GO_VERSION: '1.22'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Validate that tests pass before releasing
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Run full test suite
      run: make ci

  # Build and release binaries using GoReleaser
  release-binaries:
    name: Release Binaries
    runs-on: ubuntu-latest
    needs: test
    permissions:
      contents: write  # Required for creating releases
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Download dependencies
      run: make deps

    - name: Create .goreleaser.yaml if it doesn't exist
      run: |
        if [ ! -f .goreleaser.yaml ]; then
          cat > .goreleaser.yaml << 'EOF'
        project_name: chronos-kubernetes-scheduler

        before:
          hooks:
            - go mod tidy
            - make test

        builds:
          - id: chronos-kubernetes-scheduler
            main: ./cmd/scheduler
            binary: chronos-kubernetes-scheduler
            env:
              - CGO_ENABLED=0
            goos:
              - linux
              - darwin
              - windows
            goarch:
              - amd64
              - arm64
            ldflags:
              - -s -w
              - -X main.version={{.Version}}
              - -X main.commit={{.Commit}}
              - -X main.date={{.Date}}

        archives:
          - id: chronos-kubernetes-scheduler
            builds:
              - chronos-kubernetes-scheduler
            format: tar.gz
            format_overrides:
              - goos: windows
                format: zip
            name_template: "{{ .ProjectName }}_{{ .Version }}_{{ .Os }}_{{ .Arch }}"

        checksum:
          name_template: 'checksums.txt'

        snapshot:
          name_template: "{{ incpatch .Version }}-next"

        changelog:
          sort: asc
          filters:
            exclude:
              - '^docs:'
              - '^test:'
              - '^chore:'

        release:
          github:
            owner: "{{ .Env.GITHUB_REPOSITORY_OWNER }}"
            name: "chronos-kubernetes-scheduler"
          draft: false
          prerelease: auto
          name_template: "Release {{ .Tag }}"
          header: |
            ## FastestEmptyNode Scheduler {{ .Tag }}
            
            This release includes the scheduler plugin binary for multiple platforms.
          footer: |
            ## Installation
            
            ### Download Binary
            ```bash
            # Linux AMD64
            wget https://github.com/{{ .Env.GITHUB_REPOSITORY }}/releases/download/{{ .Tag }}/chronos-kubernetes-scheduler_{{ .Tag }}_linux_amd64.tar.gz
            tar -xzf chronos-kubernetes-scheduler_{{ .Tag }}_linux_amd64.tar.gz
            
            # macOS AMD64
            wget https://github.com/{{ .Env.GITHUB_REPOSITORY }}/releases/download/{{ .Tag }}/chronos-kubernetes-scheduler_{{ .Tag }}_darwin_amd64.tar.gz
            tar -xzf chronos-kubernetes-scheduler_{{ .Tag }}_darwin_amd64.tar.gz
            ```
            
            ### Deploy to Kubernetes
            ```bash
            kubectl apply -f https://github.com/{{ .Env.GITHUB_REPOSITORY }}/releases/download/{{ .Tag }}/manifests.yaml
            ```
        EOF
        fi

    - name: Run GoReleaser
      uses: goreleaser/goreleaser-action@v5
      with:
        distribution: goreleaser
        version: latest
        args: release --clean
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}

  # Build and push Docker images
  release-docker:
    name: Release Docker Images
    runs-on: ubuntu-latest
    needs: test
    permissions:
      contents: read
      packages: write
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=semver,pattern={{major}}
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: build/Dockerfile
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # Create Helm chart release (Phase 2)
  release-helm:
    name: Release Helm Chart
    runs-on: ubuntu-latest
    needs: [test, release-binaries, release-docker]
    if: startsWith(github.ref, 'refs/tags/v')
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Configure Git
      run: |
        git config user.name "$GITHUB_ACTOR"
        git config user.email "$GITHUB_ACTOR@users.noreply.github.com"

    - name: Install Helm
      uses: azure/setup-helm@v3
      with:
        version: v3.12.0

    - name: Package Helm chart (if exists)
      run: |
        if [ -d "charts/chronos-kubernetes-scheduler" ]; then
          # Update chart version to match release tag
          TAG=${GITHUB_REF#refs/tags/}
          VERSION=${TAG#v}
          sed -i "s/^version:.*/version: $VERSION/" charts/chronos-kubernetes-scheduler/Chart.yaml
          sed -i "s/^appVersion:.*/appVersion: $VERSION/" charts/chronos-kubernetes-scheduler/Chart.yaml
          
          # Package the chart
          helm package charts/chronos-kubernetes-scheduler
          
          echo "Helm chart packaged successfully"
        else
          echo "No Helm chart found - skipping Helm release"
        fi

    - name: Upload Helm chart to release
      if: hashFiles('*.tgz') != ''
      run: |
        TAG=${GITHUB_REF#refs/tags/}
        for chart in *.tgz; do
          gh release upload $TAG "$chart"
        done
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Update deployment manifests with new image version
  update-manifests:
    name: Update Deployment Manifests
    runs-on: ubuntu-latest
    needs: [release-docker]
    permissions:
      contents: write
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Update image version in manifests
      run: |
        TAG=${GITHUB_REF#refs/tags/}
        
        # Update the image tag in deployment manifests
        sed -i "s|image: chronos-kubernetes-scheduler:latest|image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG#v}|g" deploy/manifests.yaml
        
        # Create versioned manifest for this release
        cp deploy/manifests.yaml deploy/manifests-${TAG#v}.yaml

    - name: Upload manifests to release
      run: |
        TAG=${GITHUB_REF#refs/tags/}
        gh release upload $TAG deploy/manifests-${TAG#v}.yaml
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Send notifications
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [release-binaries, release-docker]
    if: always()
    steps:
    - name: Determine release status
      id: status
      run: |
        if [[ "${{ needs.release-binaries.result }}" == "success" && "${{ needs.release-docker.result }}" == "success" ]]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "message=✅ Release completed successfully" >> $GITHUB_OUTPUT
        else
          echo "status=failure" >> $GITHUB_OUTPUT
          echo "message=❌ Release failed" >> $GITHUB_OUTPUT
        fi

    - name: Create release summary
      run: |
        TAG=${GITHUB_REF#refs/tags/}
        cat >> $GITHUB_STEP_SUMMARY << EOF
        # 🚀 Release Summary: $TAG
        
        ## Status: ${{ steps.status.outputs.message }}
        
        ### 📦 Artifacts Released
        - **Binaries**: Linux, macOS, Windows (AMD64, ARM64)
        - **Docker Images**: Multi-architecture (AMD64, ARM64)
        - **Kubernetes Manifests**: Ready for deployment
        
        ### 🔗 Release Links
        - [GitHub Release](https://github.com/${{ github.repository }}/releases/tag/$TAG)
        - [Docker Images](${{ env.REGISTRY }}/${{ env.IMAGE_NAME }})
        
        ### 📋 Quick Install
        \`\`\`bash
        # Deploy to Kubernetes
        kubectl apply -f https://github.com/${{ github.repository }}/releases/download/$TAG/manifests-${TAG#v}.yaml
        \`\`\`
        EOF

    # Optional: Send Slack notification (uncomment and configure if needed)
    # - name: Send Slack notification
    #   if: always()
    #   uses: 8398a7/action-slack@v3
    #   with:
    #     status: ${{ steps.status.outputs.status }}
    #     channel: '#releases'
    #     message: |
    #       ${{ steps.status.outputs.message }}
    #       Release: ${{ github.ref }}
    #       Repository: ${{ github.repository }}
    #   env:
    #     SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
